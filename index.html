<html>
<head>
	<title>Straight outta the maze_path</title>
	<style>
	*{
		margin: 0;
		transition: all 1s linear;
	}
	body{
		width: 100vw;
		height: 100vh;
	}

	div#score.active{
		/*right: 0;*/
		top:0;
	}


	div#score{
		position: absolute;
	    right: 0;
	    top: -100%;
	    background: #000;
		opacity: 0.95;
	    width: 200px;
	    height: 70px;
	    border-bottom-left-radius: 6px;
	    border-left: 2px solid #fff;
	    border-bottom: 5px solid #fff;
	    color: #88ff64;
	    text-align: center;
	    vertical-align: middle;
	    /* justify-content: center; */
	    display: flex;
	    justify-content: center;
	    align-items: center;
	    font-size: 2em;
	    font-family: monospace;
	}
	div#score span{
		position: absolute;
		top:0;
		left: 0;
		font-size: 0.75em;
		font-variant: small-caps;
		padding: 3px 6px;

	}

	div#inventory.active{
		bottom: 0;
		/*right: 0;*/
	}

	div#inventory{
		position: absolute;
		bottom: -100%;
		right: 0;
		display: flex;
		border-top-left-radius: 6px;
		background: #000;
		opacity: 0.95;
		border-left: 2px solid #fff;
		border-top: 2px solid #fff;
		padding: 10px;
		/*width: 300px;*/
		flex-wrap: wrap;
		/*width: fit-content;*/
		transition: all 1s linear;
	}

	.collectible{
		/*padding: 10px;*/
		margin: 10px;
		position: relative;
		background: #000;
	}
	.overlay{
		position: absolute;
		top:0;
		right:0;
		font-family: monospace;
		background: transparent;
		font-size: 0;
		display: flex;
	    justify-content: center;
	    align-items: center;
	}
	.material img{
		width: 60px;
		height: 60px;
	}

	.collectible[data-collected=false] .overlay{
		background: #000;
		opacity: 0.95;
		border: 1px solid #88ff64;
		color: #ddd;
	    font-size: 1.3em;
	    width: 100%;
		height: 100%;
	}

	.key{
		background: #fff;
	    /*border: 2px solid #f00; */
	    border-radius: 50%;
	}

	.key .overlay{
		border-color: #f00 !important;
		border-radius: 50%;
		transition: all 1s linear;
	}

	.box-cont{
		position: absolute;
	    display: flex;
	    -webkit-justify-content: center;
	    justify-content: center;
	    align-items: center;
	    background: #000;
	    top: 0;
	    left: 0;
	    width: 100vw;
	    height: 100vh;
	    color: #88ff64;
	    opacity: 1;
	    transition: all 1s linear;
	}

	.box-cont.fade-out{
		opacity: 0;
	}

	.box{
		/* border: 1px solid #fff; */
	    font-family: arial;
	    padding: 10px;
	    border-radius: 6px;
	}
	.box .options{
		display: flex;
		-webkit-justify-content: space-evenly;
		        justify-content: space-evenly;
	}

	.box .options a{
		margin: 10px;
		cursor: pointer;
	    /* border: 1px solid #fff; */
	    padding: 10px;
	    border-radius: 3px;
	    transition: all 1s linear;
	}

	.box .option:hover, .box .option:focus{
		background: #3c3c3c;
	}	
	</style>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js"></script>

<script>
	// to select elements from html
	var $$ = (e) => document.querySelector(e);
	var $ = (p, e) => p.querySelector(e);
	var make = (n) => document.createElement(n);
	var div = () => make('div');

	var {PI, sin, cos, min, max} = Math;

	function load_material(url){
		const loader = new THREE.TextureLoader();
		return loader.load(url);
	}

	// GAME CONSTANTS
	
	
	const WAIT = 6;
	const GO_RIGHT = 7;
	const GO_LEFT = 8;
	const GO_FORWARD = 9;
	const FADING_OUT = 10;
	const DONE = 11;
	const FADING_IN = 13;
	const START = 14;
	const SHAKING = 15;

	const NORTH = 100;
	const EAST = 101;
	const WEST = 102;
	const SOUTH = 103;

	var playerInput;
	var t = null;
	
	var rand_num = function(upper){
		return Math.floor(Math.random()*(upper + 1));
	}

	function find_rand_empty(arr){
		var n = arr.length;
		var x = rand_num(n - 1);
		var y = rand_num(n - 1);
		var a = 0;
		while(arr[x][y] != 0 && a < n*n){
			a += 1;
			x = rand_num(n - 1);
			y = rand_num(n - 1);
		}
		if(a == n*n){
			console.log("no empty spots left!");
		}
		return [x, y]
	}

	
	var game = (function(maze_path_DIMS){
		// game scope for a specific maze_path dimension
		

		playerInput = new Object();
		var state = START;	
		var currentDirection = 0;
		var turningArc = 0;
		var direction = NORTH;
		var walkDistance = 0;
		var startX = 0;
		var startZ = 0;
		var last_update = Date.now();
		var flag=0;
		var stop_render = false;
		var empty_positions = (new Array(maze_path_DIMS)).fill(0).map(() => new Array(maze_path_DIMS).fill(0))
		empty_positions[0][0] = 1;
		var shake;
		

		var player = {};
		player.gridX = 0;
		player.gridY = 0;
		player.direction = NORTH;


		/***

		Initial function that gets called to start the game

		***/		
		function runmaze_path(){
		    // get HTML canvas element and set size
		    var maze_pathCanvas = document.getElementById("maze_pathCanvas");
		    maze_pathCanvas.width = document.body.offsetWidth;
		    maze_pathCanvas.height = document.body.offsetHeight;

		    // create scene, WEBGL renderer and camera
		    var scene = new THREE.Scene();
		    var renderer = new THREE.WebGLRenderer({ canvas: maze_pathCanvas });
		    var camera = new THREE.PerspectiveCamera( 75, maze_pathCanvas.width/maze_pathCanvas.height, 0.1, 1000 );
		    t = camera;

		    var maze_pathGrid = createmaze_pathGrid(maze_path_DIMS, maze_path_DIMS);
		 	placeWallGraphics(scene, maze_pathGrid);	    

		    var collectibles = createCollectiblesList(empty_positions);
		    collectibles=placecollectibleGraphics(scene, collectibles);
		    var obstacles = createObstaclesList(empty_positions);
		    obstacles=placeObstacleGraphics(scene, obstacles);
		    
		    var potions = magicPotion(empty_positions, scene);
		    
		    var inventory = new Inventory($$("#inventory"), collectibles, potions);

		    var score_man = new ScoreManager($$("#score"), [...obstacles,...collectibles], {
		    	aim: 200,
		    	action: inventory.giveKey
		    }, inventory.hasPotion, inventory.usePotion);
		    var nobox = true;

		    createDoor(scene);
		    createDoor(scene, -0.055)

		   	// create Light source
		   	var playerPointLight = new THREE.PointLight();
		   	playerPointLight.position.set(0,0,0);
		   	scene.add(playerPointLight);

		   	var render = function () {
		   		var now = Date.now();
		   		var deltaTime = now - last_update;
		   		last_update = now;
		   		if(state == START){
		   			scene.children.forEach( ({material}) => {
						if(material){
							material.transparent = true;	
							material.opacity = 0;
							return material.opacity;
						}
						return 0;
					});

					state = FADING_IN;
		   		}else if(state == FADING_IN){
		   			var ops = scene.children.map(({material}) => {
						if(material){
							material.transparent = true;	
							material.opacity += 0.03;
							return material.opacity;
						}
						return 1;
					}).filter( e => e < 1);
		   			if(ops.length == 0){
		   				state = WAIT;
		   			}

		   		}else if(state == SHAKING){
		   			
		   			var axis_dir = {
		   				100: 'z', // NORTH
		   				101: 'x', // EAST
		   				102: 'x', // WEST
		   				103: 'z', // SOUTH
		   			}

		   			var prev = shake.value();
		   			shake.update();
		   			var disp = shake.value() - prev;

		   			var a = axis_dir[direction];
		   			
		   			camera.position[a] += disp;
		   			
		   			if(shake.done()){
		   				state = WAIT;
		   			}
		   		}


		   		
				if(state == WAIT){  // WAIT for user input
					   // if player has given an input, make a move
					if(playerInput.left){
					   	state = GO_LEFT;
					   	switch(direction){
					   		case NORTH:
					   		direction = WEST;
					   		break;
					   		case EAST:
					   		direction = NORTH;
					   		break;
					   		case SOUTH:
					   		direction = EAST;
					   		break;
					   		case WEST:
					   		direction = SOUTH;
					   		break;
					   	}
						   player.direction = direction; //Sync player and camera
					}
					else if(playerInput.right){
						state = GO_RIGHT;
						switch(direction){
							case NORTH:
							direction = EAST;
							break;
							case EAST:
							direction = SOUTH;
							break;
							case SOUTH:
							direction = WEST;
							break;
							case WEST:
							direction = NORTH;
							break;
						}
					   player.direction = direction; //Sync player and camera
					}
					else if (playerInput.up ){
						if(validMove(maze_pathGrid, player.gridX, player.gridY, player.direction)){
							walkingDistance = 0;
							startX = camera.position.x;
							startZ = camera.position.z;
							state = GO_FORWARD;
							switch(direction){
								case NORTH:
								player.gridX--;
								break;
								case EAST:
								player.gridY++;
								break;
								case SOUTH:
								player.gridX++;
								break;
								case WEST:
								player.gridY--;
								break;
							}
						}else{
							// shake animation 
							var a = 0.3;
							if(direction == WEST || direction == NORTH)
								a *= -1.0;
							shake = new Shaker(90, a);
							state = SHAKING;
						}
					}else if(playerInput.enter){
						// console.log(player);
						if(inventory.hasKey && direction == NORTH
							&& player.gridX == 0 && player.gridY == 0){
							state = FADING_OUT;
							// console.log("Yay, level done!");
						}
					}
				}

				if(state == FADING_OUT){
					var ops = scene.children.map( ({material}) => {
						if(material){
							material.transparent = true;	
							material.opacity -= 0.03;
							return material.opacity;
						}
						return 0;
					}).filter(e => e > 0);

					if(ops.length == 0){
						state = DONE;
					}
				}
				if(state == DONE){
					if(nobox){
						nobox = false;
						var doNothing = () => {};

						function stopGame(){
							// destroy current scene, camera etc
							stop_render = true;

							// We are using a recursive call to start the next game.
							// dispose everything, so that GC can collect it,
							// although scope is not destroyed
							
							// from a discourse thread
							renderer.dispose();
							const cleanMaterial = material => {
								// console.log('dispose material!')
								material.dispose()

								// dispose textures
								for (const key of Object.keys(material)) {
									const value = material[key]
									if (value && typeof value === 'object' && 'minFilter' in value) {
										// console.log('dispose texture!')
										value.dispose()
									}
								}
							}

							scene.traverse(object => {
								if (!object.isMesh) return
								// console.log('dispose geometry!')
								object.geometry.dispose()
								if (object.material.isMaterial) {
									cleanMaterial(object.material)
								} else {
									// an array of materials
									for (const material of object.material) cleanMaterial(material)
								}
							})

							scene = null;
							camera = null;
							renderer = null;
							
							
						}
						inventory.dispose();
						score_man.dispose();
						// wait a few secs for suspense and animations
						setTimeout(() => {
							displayMessage("Ready for the next one?", ["Yes", () => {
								stopGame();
								game(maze_path_DIMS + 2);
							}], ["No", stopGame]) 
						}, 400);
					}
				}

				if(state == GO_LEFT){
					turningArc += Math.PI/2  * deltaTime/1000;
					if(turningArc >= Math.PI/2){
						turningArc = Math.PI/2;
						currentDirection = currentDirection + turningArc;
						turningArc = 0;
						state = WAIT;
					}

					camera.rotation.y = currentDirection + turningArc;
				}

				if(state == GO_RIGHT){
					turningArc += Math.PI/2  * deltaTime/1000;
					if(turningArc >= Math.PI/2){
						turningArc = Math.PI/2;
						currentDirection = currentDirection - turningArc;
						turningArc = 0;
						state = WAIT;
					}

					camera.rotation.y = currentDirection - turningArc;
				}

				if(state == GO_FORWARD)
				{

					walkingDistance += 1 * deltaTime/1000;
					if(walkingDistance >= 1){
						walkingDistance = 1;
						state = WAIT;
						collectibles=processCollisions(player.gridX, player.gridY,collectibles,scene);
						obstacles=processCollisions(player.gridX, player.gridY,obstacles,scene);
						potions=processCollisions(player.gridX, player.gridY,potions,scene);

					}
					switch(direction){
						case NORTH:
						camera.position.z = startZ - walkingDistance;
						break;
						case EAST:
						camera.position.x = startX + walkingDistance;
						break;
						case SOUTH:
						camera.position.z = startZ + walkingDistance;
						break;
						case WEST:
						camera.position.x = startX - walkingDistance;
						break;
					}
					playerPointLight.position.x = camera.position.x;
					playerPointLight.position.y = camera.position.y;
					playerPointLight.position.z = camera.position.z;
					// 	collectibles.forEach(function(collectible){
						
					//    var collectibleObject = scene.getObjectById( collectibles.id);
					//    if (flag++<10) console.log(collectibleObject.id);
					//    collectibleObject.rotation.x += 2 * deltaTime/1000;
					//    collectibleObject.rotation.y += 2 * deltaTime/1000;

					// });
				}
				if(!stop_render){
					scene.traverse (function (object){	
						if (object.name==='collect' || object.name==='potion'){
							object.rotation.x += 2 * deltaTime/1000;
							object.rotation.y += 2 * deltaTime/1000;
						}

					});
					renderer.render(scene, camera);
					// recursive call [ call when js animation micro-calls are done]
					requestAnimationFrame( render );
				}
			};

			render();
		}
		runmaze_path()
	});

	

	// check if move is
	function validMove(maze_pathGrid, x, y, direction){
		if(direction == NORTH)
		{
			return !maze_pathGrid[x][y].north_walls;
		}
		else if(direction == EAST)
		{
			return !maze_pathGrid[x][y].east_walls;
		}
		else if(direction == SOUTH)
		{
			return !maze_pathGrid[x][y].south_walls;
		}
		else if(direction == WEST)
		{
			return !maze_pathGrid[x][y].west_walls;
		}
		return false;
	}


	// create maze_path
	function createmaze_pathGrid(width, height){
		function maze_pathCell(north_walls, east_walls, south_walls, west_walls){
			this.north_walls = north_walls;
			this.east_walls = east_walls;
			this.south_walls = south_walls;
			this.west_walls = west_walls;
		}
		var maze_pathGrid = Array(height);

		for( var i = 0; i<height; i++){
			var row = Array(width);
			for(var j = 0; j<width; j++){
				row[j] = new maze_pathCell(true,true,true,true);
			}
			maze_pathGrid[i] = row;

		}
		for( var i = 0; i<height; i++){
			for(var j = 0; j<width; j++){
		      if(i>0 && j>0){ //If it is not an edge cell open a passage randomly
		      	if(Math.random()>0.5){
		      		maze_pathGrid[i][j].north_walls=false;
		      		maze_pathGrid[i-1][j].south_walls=false;
		      	}
		      	else{
		      		maze_pathGrid[i][j].west_walls=false;
		      		maze_pathGrid[i][j-1].east_walls=false;
		      	}
		      }
		      else if(j > 0){ //If it is along the north edge open a west passage
		      	maze_pathGrid[i][j].west_walls=false;
		      	maze_pathGrid[i][j-1].east_walls=false;
		      }
		      else if(i > 0){ //If it is along the west edge open a north passage
		      	maze_pathGrid[i][j].north_walls=false;
		      	maze_pathGrid[i-1][j].south_walls=false;
		      }
		  }
		}
		
		return maze_pathGrid;
	}


	// place wall graphics on screen
	function placeWallGraphics(scene, maze_pathGrid){
		var wallGeometry = new THREE.BoxGeometry( 1.059, 0.5 ,0.06);
		const loader = new THREE.TextureLoader();
		var wallMaterial = new THREE.MeshPhongMaterial({map: loader.load('./images/wall.jpg'),});

		maze_pathGrid.forEach(function(maze_pathRow, rowCount){
			maze_pathRow.forEach(function(maze_pathCell, colCount){
				if(maze_pathCell.north_walls)
					placeWall(colCount, rowCount, 'n');
				if(maze_pathCell.east_walls)
					placeWall(colCount, rowCount, 'e');
				if(maze_pathCell.south_walls)
					placeWall(colCount, rowCount, 's');
				if(maze_pathCell.west_walls)
					placeWall(colCount, rowCount, 'w');
				var floorGeometry=new THREE.PlaneGeometry(1,1,0.1);
				const loader = new THREE.TextureLoader();
				var floorMaterial = new THREE.MeshPhongMaterial({map: loader.load('./images/floor.jpg'),});
				var floor= new THREE.Mesh(floorGeometry,floorMaterial);
				floor.position.z=rowCount;
				floor.position.x=colCount;
				floor.position.y=-0.25;
				floor.rotation.x=-Math.PI/2;
				scene.add(floor);
			});
		});

		function placeWall(x,y,direction){
			var wall = new THREE.Mesh( wallGeometry, wallMaterial );
			wall.name='wall';
			wall.position.z = y*1;
			wall.position.x = x*1;
			if(direction == 'n'){
				wall.position.z -= 0.5;
			}
			else if(direction == 'e'){
				wall.position.x += 0.5;
				wall.rotation.y = -Math.PI/2;
			}
			else if(direction == 's'){
				wall.position.z += 0.5;
				wall.rotation.y = Math.PI;
			}
			else if(direction == 'w'){
				wall.position.x -= 0.5;
				wall.rotation.y = Math.PI/2;
			}
			else{
				return false;
			}

			scene.add(wall);
		}
	}

	// create collectibles
	function createCollectiblesList(empty_positions){		
		const loader = new THREE.TextureLoader();
		function _create_({material, score}, index, type){
			var [x, y] = find_rand_empty(empty_positions);
			empty_positions[x][y] = 1;
			return new collectible(x, y, index, material, loader, score, type);
		}

		var collectibles = [];
		var k = 0;
		for(var i in itemTypes){
			var item = itemTypes[i];
			for(var j = 0; j < item.quantity; j++){
				collectibles.push(_create_(item, k, i));
				k++;
			}
		}

		return collectibles;
	}

	function placeBoxOnScene(scene, items, dims, name, materialName){
	  var itemGeometry = (new THREE.BoxGeometry(...dims));
	  items.forEach(function(item){
	  	var {x, y} = item;
	  	// console.log(x, y);
	  	var geometry = item.geometry || itemGeometry;
	   	var itemObject = new THREE.Mesh(geometry ,item[materialName]);
	   	item.id=itemObject.id;
	   	itemObject.name=name;
	   	itemObject.position.z = x;
	   	itemObject.position.x = y;
	   	scene.add(itemObject);
	   });
	   return items;
	}

	function magicPotion(empty_positions, scene){
		var l = potionTypes.length;
		var k = 0;
		var potions = [];
		for(var i = 0; i< l; i++){
			var potion = potionTypes[i]
			var t = potion.quantity;
			for(var j = 0; j< t; j++){
				var m = new THREE.MeshStandardMaterial({map: load_material(potion.material)});
				var g = new THREE.IcosahedronGeometry(0.125); //, 100, 100
				var p = new Potion(...find_rand_empty(empty_positions), k, m, g, i);
				potions.push(p);
				k++;
			}

		}

		return placeBoxOnScene(scene, potions, [1, 1, 1], 'potion', 'material');
	}


	// place collectible graphics on screen
	function placecollectibleGraphics(scene, collectibles){
	 	return placeBoxOnScene(scene, collectibles, [0.25, 0.25, 0.25], 'collect', 'collectibleMaterial');
	}

	// call if any collectible collided
	function processcollectibleCollisions(x, y,collectibles,scene){
		collectibles.forEach(function(collectible,index){
			if(collectible.x == x && collectible.y == y){
	         collectible.action(); //Run the object's event
	         var id=collectible.id;
	         //var collectibleObject = scene.getObjectById( collectibles.id );
	         // scene.remove(collectibleObject); //Remove graphics from scene
	         collectibles.splice(index,1); //Remove collectible from list
	    	}
		    var obj;
		    scene.traverse(function (object){	
		     	if (object.id==id){
		     		obj=object;
		     	}
		     });
	    	scene.remove(obj);
	 	});
		return collectibles;
	}


	// create obstacles
	function createObstaclesList(empty_positions){		
		const loader = new THREE.TextureLoader();
		

		// create map with every position empty
		function _create_({material, score}, index, type){
			var [x, y] = find_rand_empty(empty_positions);
			empty_positions[x][y] = 1;
			return new Obstacle(x, y, index, material, loader, score, type);
		}

		var obstacles = [];
		var k = 0;
		for(var i in obstacleTypes){
			var item = obstacleTypes[i];
			for(var j = 0; j < item.quantity; j++){
				obstacles.push(_create_(item, k, i));
				k++;
			}
		}

		return obstacles;
	}

	


	// place obstacle graphics on screen
	function placeObstacleGraphics(scene, obstacles){
		var obstacleGeometry = new THREE.BoxGeometry(1.0, 0.5 ,1.0);
	   //const loader = new THREE.TextureLoader();
	   // var obstacleMaterial= new THREE.MeshPhongMaterial( {map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRjJzLwvs5JHTGVuezxnv7_zy0qZdS2ytQ25LLMGgMt4bFERLgWCA')});
	   //var obstacleMaterial=new THREE.MeshStandardMaterial({color:"red"});
	   obstacles.forEach(function(obstacle){
	   	var obstacleObject = new THREE.Mesh(obstacleGeometry,obstacle.obstacleMaterial);
	   	obstacle.id=obstacleObject.id;
	   	obstacleObject.name='obstacle';
	   	obstacleObject.position.z = obstacle.x;
	   	obstacleObject.position.x = obstacle.y;
	   	console.log(obstacle.x,obstacle.y);
	   	scene.add(obstacleObject);
	   });
	   return obstacles;
	}

	/***
		See Process collisions defined below
	****/
	// // call if any collectible collided
	// function processObstacleCollisions(x, y,obstacles,scene){
	// 	obstacles.forEach(function(obstacle,index){
	// 		if(obstacle.x == x && obstacle.y == y){
	//          obstacle.action(); //Run the object's event
	//          var id=obstacle.id;
	//          //var obstacleObject = scene.getObjectById( obstacles.id );
	//          // scene.remove(obstacleObject); //Remove graphics from scene
	//          obstacles.splice(index,1); //Remove obstacle from list
	    	
	// 		    var obj;
	// 		    scene.traverse(function (object){	
	// 		     	if (object.id==id){
	// 		     		obj = object;
	// 		     	}
	// 		     });
	// 	    	scene.remove(obj);
	//     	}
	//  	});
	// 	return obstacles;
	// }

	// function processPotionCollisions(x, y, potions, scene){
	// 	console.log(potions)
	// 	return potions.map(function(potion, index) {
	// 		console.log("check", potion.x, potion.y, x, y)
	// 		if(potion.x == x && potion.y == y){
	// 			potion.action();
	// 			var id = potion.id;
				
	// 			var obj;
	// 			scene.traverse(function (object){	
	// 			     	if (object.id==id){
	// 			     		obj = object;
	// 			     	}
	// 		     });
	// 			console.log(obj)
	// 	    	scene.remove(obj);
	// 	    	return null;
	// 		}
	// 		return potion;
	// 	}).filter(e => e != null);
	// }


	// a function that checks collision with any item
	// of type {x, y, action}
	function processCollisions(x, y, items, scene){
		return items.map(function(item, index) {
			console.log("check", item, item.x, item.y, x, y)
			if(item.x == x && item.y == y){
				if(item.action)
					item.action();
				
				var id = item.id;
				var obj;
				scene.traverse(function (object){	
				     	if (object.id==id){
				     		obj = object;
				     	}
			     });
				console.log(obj)
		    	scene.remove(obj);
		    	return null;
			}
			return item;
		}).filter(e => e != null);
	}

</script>

<script>
	/***
	change player input on key down
***/
function key_down(event){
   var keynum;

   if(window.event){ //Browser is IE
      keynum = event.keyCode;
   }
   else{
      keynum = event.which;
   }

   if(keynum == 37){
      playerInput.left = 1;
   }
   else if(keynum == 38){
      playerInput.up = 1;
   }
   else if(keynum == 39){
      playerInput.right = 1;
   }
   else if(keynum == 40){
      playerInput.down = 1;
   }else if(keynum == 13){
      playerInput.enter = 1;
   }
}


/***
	change player input on key up
***/
function key_up(event){
   var keynum;
   
   if(window.event){ //Browser is IE
      keynum = event.keyCode;
   }
   else{
      keynum = event.which;
   }

   if(keynum == 37){
      playerInput.left = 0;
   }
   else if(keynum == 38){
      playerInput.up = 0;
   }
   else if(keynum == 39){
      playerInput.right = 0;
   }
   else if(keynum == 40){
      playerInput.down = 0;
   }else if(keynum == 13){
      playerInput.enter = 0;
   }
}

function addClass(ele, name){
   if(ele.className.match(name) == null)
      ele.className += (" " + name);
}
function removeClass(ele, name){
   var c = ele.className
   if(c.match(name) != null)
      ele.className = c.replace(name, "");
}

function createDoor(scene, x=-0.3, y=0, z=-0.465){
   var size = (x) => [x, 2*x];
   var doorGeometry = new THREE.PlaneGeometry(...size(0.25),0.1);
   // scene.add(doorGeometry);

   const loader = new THREE.TextureLoader();
   var doorMaterial = new THREE.MeshPhongMaterial({map: loader.load('./images/door.jpg'),});
   var door = new THREE.Mesh(doorGeometry,doorMaterial);
   door.position.z=z;
   door.position.x=x;
   door.position.y=y;
   scene.add(door);
}

function displayMessage(str, ...options){
   var container = div();
   container.className = "box-cont";
   var box = div();
   box.className = "box";
   
   var optionDiv = div();
   optionDiv.className = "options";
   options.forEach(([name, handler]) => {
      var a = make('a');
      a.className = "option";
      // var d = div();
      a.innerText = name;
      a.addEventListener('click', () => {
         container.className += " fade-out";
         setTimeout( () => {
            container.remove();
            handler();
         }, 800);
      });
      // a.appendChild(d);
      optionDiv.appendChild(a);
   })
   

   var msgDiv = div();
   msgDiv.className = "message";
   msgDiv.innerHTML = '<p>' + str + '</p>';
   box.appendChild(msgDiv);
   box.appendChild(optionDiv);
   container.appendChild(box);
   document.body.appendChild(container);
   if(optionDiv.children.length != 0)
      optionDiv.children[0].focus();
}

function bind(o, f){
   return o[f].bind(o);
}
</script>
<script >
	// prototype class
/*****
	General Item
****/
function Item(){}

Item.prototype.hook = function(f){
	this.subjects.push(f);
}

Item.prototype.notify = function(){
	this.subjects.forEach(f => f(this));
}


/*****
	collectible Item
****/
// collectible object constructor
function collectible(x, y, index, url, loader, score, type){
	this.x = x;
	this.y = y;
	this.id = null;
	this.index = index;
	this.url = url;
	this.collectibleMaterial = new THREE.MeshStandardMaterial( {map: loader.load(url)});
	this.score = score;
	this.collected = false;
	this.subjects = [];
	this.type = type; // uses itemTypes[type]
}

// new object with all elements of Item.prototype
collectible.prototype = Object.assign({}, Item.prototype);

collectible.prototype.action = function() {
	this.collected = true;
	this.notify();
};


/*****
	Obstacle Item
****/
function Obstacle(x, y, index, url, loader, score, type){
	this.x = x;
	this.y = y;
	this.id = null;
	this.index = index;
	this.url = url;
	this.obstacleMaterial = new THREE.MeshStandardMaterial({ color: "#FFF", transparent: true, alphaTest: 0.0 });
	var alphaMap = new THREE.TextureLoader().load(url);
	this.obstacleMaterial.alphaMap = alphaMap;
	this.obstacleMaterial.alphaMap.magFilter = THREE.NearestFilter;
	this.obstacleMaterial.alphaMap.wrapT = THREE.RepeatWrapping;
	this.obstacleMaterial.alphaMap.repeat.y = 1;
	this.score = score;
	this.collected = false;
	this.subjects = [];
	this.type = type; // uses obstacleTypes[type]
}

Obstacle.prototype = Object.assign({}, collectible.prototype);


/*****
	Potion Item
****/
function Potion(x, y, index, material, geometry, type){
	this.x = x;
	this.y = y;
	this.id = null;
	this.index = index;
	this.material = material;
	this.geometry = geometry;
	this.collected = false;
	this.subjects = [];
	this.type = type; // uses itemTypes[type]
}

// new object with all elements of Item.prototype
Potion.prototype = Object.assign({}, collectible.prototype);

</script>
<script>
	
var obstacleTypes = [{
	material: "./images/o1.png",
	score: -5,
	quantity: 4,
},
{
	material: "./images/o2.png",
	score: -10,
	quantity: 4,
}]

var potionTypes = [{
	material: "./images/p1.jpg",
	quantity: 1
}]


var itemTypes = [{
	material: "./images/i1.jpg",
	score: 10,
	quantity: 2,
},
{
	material: "./images/i2.jpg",
	score: 20,
	quantity: 2,
},
{
	material: "./images/i3.jpg",
	score: 30,
	quantity: 2,
},
{
	material: "./images/i4.jpg",
	score: 40,
	quantity: 1,
},
{
	material: "./images/i5.jpg",
	score: 50,
	quantity: 1,
},
{
	material: "./images/i6.jpg",
	score: 100,
	quantity: 1,
}]
</script>
<script>
	function Shaker(r, A=0.3, phi=0, omega=1){
	this.A = A;
	this.phi = phi;
	this.omega = omega;
	this.d = -A/r;
	this.t = 0;
	this.inc = 2*PI/r;
	this.calculate();
}

Shaker.prototype.value = function(){
	return this.val;
}	

Shaker.prototype.update = function(){
	this.A += this.d;
	// console.log(this.A);
	this.t += this.inc;
	this.calculate();
}

Shaker.prototype.calculate = function(){
	var {A, phi, omega, t} = this;
	this.val = A*sin(omega*t + phi);
}

Shaker.prototype.done = function(){
	return this.t >= 2*PI;
}
</script>
<script>
	

/*****
	Score Manager
****/
function ScoreManager(ele, items, target, hasPotion, potionUsed){
	// hook a notification function on the collectibles
	items.forEach(m => m.hook(this.notification.bind(this)))
	this.ele = ele;
	var {aim, action}= target;
	this.aim = aim;
	this.action = action;
	this.hasPotion = hasPotion;
	this.potionUsed = potionUsed;
	addClass(this.ele, "active");
	this.update(0);
}

// notified by item when it is collected
ScoreManager.prototype.notification = function(item){
	console.log(item.score);
	if(item.score < 0 && this.hasPotion()){

		this.potionUsed();
		return;
	}
	console.log(this.hasPotion());
	this.update(this.score + item.score);
	// console.log("ScoreManager says  score is ", this.score);
	if(this.score >= this.aim){
		this.action();
	}
}

ScoreManager.prototype.update = function(n){
	this.score = n;
	$(this.ele, "p").innerText = this.score;
}

ScoreManager.prototype.dispose = function(){
	console.log("dispose score manager");
	removeClass(this.ele, "active");		
}

/*****
	Inventory Manager
****/
function Inventory(container, collectibles, potions){
	this.collectibles = collectibles;
	this.collectedTypes = {}
	this.container = container;

	// hook a notification function on the collectibles
	this.collectibles.forEach(m => {
		this.collectedTypes[m.type] = false;
		m.hook(this.notification.bind(this))
	});
	potions.forEach(m => {
		m.hook(this.addPotion.bind(this));
	})

	this.panel = {};
	var scope = this;

	this.collectibles.map(ele => {
		var o = scope.createDisplay(ele);
		this.panel[ele.id] = o;
		return o;
	}).forEach(ele => {
		container.appendChild(ele);
	})
	this.key = this.createKey();
	container.appendChild(this.key);

	this.hasKey = false;

	// will be called by another function.
	// so, bind this to my scope.
	this.giveKey = this.giveKey.bind(this);
	this.addPotion = this.addPotion.bind(this);
	this.usePotion = this.usePotion.bind(this);
	this.hasPotion = this.hasPotion.bind(this);

	addClass(container, "active");
	this.potion = 0;
}

Inventory.prototype.addPotion = function(){
	
	this.potion += 1;
}

Inventory.prototype.usePotion = function(){
	this.potion -= 1;
}

Inventory.prototype.hasPotion = function(){
	
	return this.potion > 0;
}

Inventory.prototype.createKey = function(){
	var keyImage = "./images/key.svg";
	var d = document.createElement("div");
	d.className = "collectible key";
	d.setAttribute('data-collected', false);
	d.innerHTML = ('<div class="overlay"></div>' +
		'<div class="material"><img src="' + keyImage + '"></div>');
	return d;
}

Inventory.prototype.createDisplay = function(obj){
	var {id, url, collected, score} = obj;
	var d = document.createElement("div");
	d.className = "collectible";
	d.setAttribute('data-collected', collected);
	d.innerHTML = ('<div class="overlay"><p> +' + score + '</p></div>' +
	'<div class="material"><img src="' + url + '"></div>');
	return d;
}

// notified by collectible when it is collected
Inventory.prototype.notification = function(collectible){
	// console.log("Inventory says ", collectible, "is collected");
	this.panel[collectible.id].setAttribute('data-collected', collectible.collected);
	this.collectedTypes[collectible.type] = true;
}

Inventory.prototype.collected_all_types = function(){
	var types = this.collectedTypes;
	for(var ct in types){
		if(!types[ct])return false;
	}
	return true;
}

Inventory.prototype.giveKey = function(){
	if(this.hasKey)return;
	
	this.hasKey = true;
	this.key.setAttribute('data-collected', true);

}

Inventory.prototype.dispose = function(){
	
	removeClass(this.container, "active");
	var scope = this;
	setTimeout(() => {
		var c = Array.from(scope.container.children);
		c.forEach(e => e.remove());
	}, 1000);
}

</script>

</head>
<body onload="game(10);" onkeydown="key_down(event);" onkeyup="key_up(event);">
	<div id="score"><span>Score</span><p></p></div>
	<canvas id="maze_pathCanvas" width=1300 height=600></canvas>
	<div id="inventory"></div>
</body>
</html>
